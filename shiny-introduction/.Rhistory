library(RODBC)
library(reshape2)
library(ggplot2)
library(data.table)
#library(lubridate)
library(bbbi)
library(doBy)
ts <- summaryBy(rev ~ cohort+user_age_at_purchase, data=data)
ts <- ts[, cumrev:=cumsum(rev), by = list(cohort)]
ts <- as.data.table(ts)
setkey(ts, user_age_at_purchase)
ts <- ts[, cumrev:=cumsum(rev), by = list(cohort)]
setkey(ts, cohort, user_age_at_purchase)
View(ts)
ts <- ts[, cumrev:=cumsum(rev), by(cohort)]
View(ts)
?data.table()
ts <- ts[, cumrev:=cumsum(rev), by list("cohort", "user_age_at_purchase")]
ts <- ts[, cumrev:=cumsum(rev), by = list("cohort", "user_age_at_purchase")]
ts <- ts[, cumrev:=cumsum(rev), by = list("cohort")]
ts <- ts[, cumrev:=cumsum(rev), by = list("cohort", user_age_at_purchase), roll=TRUE
]
ts <- ts[, cumrev:=cumsum(rev), by = list("cohort", "user_age_at_purchase"), roll=TRUE]
Tables()
tables()
X = data.table(c("b","c"),foo=c(4,2))
X
DT[X]
DT = data.table(x=rep(c("a","b","c"),each=3), y=c(1,3,6), v=1:9)
tables
tables()
setkey(DT,x)
tables()
DT
x
X
DT[,2]
DT[,2,with=FALSE]
DT[2:3,sum(v)]
DT
DT["a"]
DT[,sum(v),by=x]
DT[X]
DT
X
DT[X]
DT["a"]
DT[J("a",3)]
DT[J("a",3:6)]
DT[J("a",3:6),nomatch=0]
DT[X]
DT[X,sum(v)]
ts
ts <- ts[, cumrev:=cumsum(rev), by = list("cohort", "user_age_at_purchase"), roll=TRUE]
ts[, sum(rev)]
ts[, sum(rev), by=cohort]
ts[, sum(rev), by="cohort"]
ts[, sum(rev), by=list("cohort")]
ts
tables()
names(ts)
ts[, cumrev:=cumsum(rev.mean), by = list("cohort", "user_age_at_purchase"), roll=TRUE]
ts[, cumrev:=cumsum(rev.mean)]
ts[, cumsum(rev.mean)]
ts[, cumsum(rev.mean), by=list("cohort")]
ts[, cumsum(rev.mean), by=list(cohort)]
ts[, select=c("cohort","user_age_at_purchase",cumsum(rev.mean)), by=list(cohort)]
ts[, cumsum(rev.mean), by=list(cohort)]
test <- ts[, cumsum(rev.mean), by=list(cohort)]
View(test)
test <- ts[, cumsum:=cumsum(rev.mean), by=list(cohort)]
View(test)
test <- ts[, cumsum2:=cumsum(rev.mean), by=list(cohort), roll=TRUE]
View(test)
max(ts$user_age_at_purchase)
user_age <- seq(1:max(ts$user_age_at_purchase))
user_age
ts[user_age]
ts[user_age, roll=TRUE]
user_age
expand.grid(x = 1:10, y = 11:20)
a <- data.table(expand.grid(x = 1:10, y = 11:20))
seetkey(a, x, y)
setkey(a, x, y)
View(a)
a <- data.table(expand.grid(cohort = unique(ts$cohort), y = unique(ts$user_age_at_purchase)))
a <- data.table(expand.grid(cohort = unique(ts$cohort), user_age_at_purchase = unique(ts$user_age_at_purchase)))
head(a)
a <- data.table(expand.grid(cohort = unique(ts$cohort), user_age_at_purchase = unique(ts$user_age_at_purchase)))
setkey(a, cohort, user_age_at_purchase)
a
View(a)
a <- merge(a, ts, by = intersect(names(a), names(ts)), all.x = TRUE)
View(a)
a[is.na(rev.mean), rev.mean := 0]
View(a)
?expand.grid()
View(DT)
View(ts)
a <- data.table(expand.grid(cohort = unique(ts$cohort), user_age_at_purchase = unique(ts$user_age_at_purchase)))
a <- merge(a, ts, by = intersect(names(a), names(ts)), all.x = TRUE)
a[is.na(rev.mean), rev.mean := 0]
View(a)
ts <- merge(a, ts, by = intersect(names(a), names(ts)), all.x = TRUE)
ts[is.na(rev.mean), rev.mean := 0]
View(ts)
ts[, 1:3, with=FALSE]
ts[, cumsum(rev.mean), by=cohort]
ts[, cumsum:=cumsum(rev.mean), by=cohort]
ts <- ts[, cumsum:=cumsum(rev.mean), by=cohort]
View(ts)
ts[, !c("cumrev","cumsum2")]
ts[, !list(cumrev,cumsum2)]
ts[, cumrev=NULL]
colNum =2
ts[, select=list(cohort, user_age_at_purchase,rev.mean,cumsum)]
ts[, list(cohort, user_age_at_purchase,rev.mean,cumsum)]
ts <- ts[, list(cohort, user_age_at_purchase,rev.mean,cumsum)]
data <- as.data.table(sqldata)
setkey(data, cohort, user_age_at_purchase)
data <- data[, rev:=sum(realcurrencyamount), by = list(cohort, user_age_at_purchase)]
ts <- summaryBy(rev ~ cohort+user_age_at_purchase, data=data)
ts <- as.data.table(ts)
setkey(ts, cohort, user_age_at_purchase)
# get all possible combinations and expand.grid on them
a <- data.table(expand.grid(cohort = unique(ts$cohort), user_age_at_purchase = unique(ts$user_age_at_purchase)))
# merge back into ts,
ts <- merge(a, ts, by = intersect(names(a), names(ts)), all.x = TRUE)
# update NAs with 0
ts[is.na(rev.mean), rev.mean := 0]
# keep rows 1-3
ts[, 1:3, with=FALSE]
ts <- ts[, cumsum:=cumsum(rev.mean), by=cohort]
ts <- ts[, 1:3, with=FALSE]
ts <- ts[, cumsum:=cumsum(rev.mean), by=cohort]
View(ts)
ggplot(data=ts, aes(x=user_age_at_purchase, y=cumsum, group=cohort, colour=cohort)) +
geom_line() +
geom_point(size=4, shape=21, fill="white")
ggplot(data=ts, aes(x=user_age_at_purchase, y=cumsum, group=cohort, colour=cohort)) +
#    geom_point(size=4, shape=21, fill="white") +
geom_line()
View(ts)
fileUrl <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv"
download.file(fileUrl, destfile = "gdp.csv", method = "curl")
download.file(fileUrl, destfile = "gdp.csv")
gdp <- read.csv("./gdp.csv")
View(gdp)
fileUrl1 <- "https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv"
download.file(fileUrl1, destfile = "edu.csv")
edu <- read.csv("./edu.csv")
X=CountryCode
names(gdp)
names(edu)
head(gdp)
head(edu)
gdpclean<-gdp[5:194,]
mergedData=as.data.frame(merge(gdpclean,edu,by.x="X",by.y="CountryCode"))
mergedData$Gross.domestic.product.2012 = as.numeric(as.character(mergedData$Gross.domestic.product.2012))
summary(mergedData[mergedData$Income.Group=="High income: OECD",])
quantile(mergedData$Gross.domestic.product.2012,probs=c(0.2,0.4,0.6,0.8,1))
library(Hmisc)
install.packages("Hmisc")
library(Hmisc)
mergedData$gdp=cut2(mergedData$Gross.domestic.product.2012,g=5)
table(mergedData$Income.Group,mergedData$gdp)
mergedData$Gross.domestic.product.2012 = as.numeric(as.character(mergedData$Gross.domestic.product.2012))
file.url <- 'https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv'
file.dest <- 'GDP.csv'
# download from the URL
download.file(file.url, file.dest )
# specify the right lines
rowNames <- seq(10,200, 2)
# read the data
gdp <- read.csv('GDP.csv', header=F, skip=5, nrows=190)
View(gdp)
# second data file
file.url <- 'https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv'
file.dest <- 'GDP2.csv'
# download from the URL
download.file(file.url, file.dest )
# read second file
fed <- read.csv('GDP2.csv')
combined <- merge(gdp, fed, by.x='V1', by.y='CountryCode', sort=TRUE)
combined[with(combined, order(-V2) )]
View(combined)
library(dplyr)
arrange(combined, desc(V1))
data <- arrange(combined, desc(V1))
data
View(data)
data <- arrange(combined, desc(V2))
View(data)
str(data)
mean(combined[combined$Income.Group=='High income: OECD',]$V2)
# non OECD
mean(combined[combined$Income.Group=='High income: nonOECD',]$V2)
library("rJava")
R.Version()
install.packages('rJava', repos='http://www.rforge.net/')
library(httr)
set_config(use_proxy(url="10.26.0.16", port=3128))
install.packages('rJava', .libPaths()[1], 'http://www.rforge.net/')
install.packages('rJava', .libPaths()[1], 'http://www.rforge.net/', type="source")
myData <- data.frame( x=1:10, y=sample(1:10), z=rnorm(10) )
myData
head(myData, -1)
tail(myData, -1)
?head()
source('~/games/gitlab/mmho/hero_count.R')
mysqlconn <-odbcConnect(dsn="MMHO_DE", uid="", pwd="")
heroes <- sqlQuery(mysqlconn,"
select gen.user_id, generated_heroes, deleted_heroes, generated_heroes - deleted_heroes heroes
from(
SELECT user_id, count(1) generated_heroes
FROM mmho_emea_de_gimpli_warehouse.fct_generate_hero
group by user_id
) as gen
left outer join(
SELECT user_id, count(1) deleted_heroes
FROM mmho_emea_de_gimpli_warehouse.fct_delete_hero
group by user_id
) as del on gen.user_id = del.user_id
", stringsAsFactors=FALSE)
View(heroes)
close(mysqlconn)
source('~/games/gitlab/mmho/hero_count.R')
View(heroes)
geom_histogram()
q <- ggplot(heroes, aes(x=heroes))+
geom_histogram()
library(ggplot2)
q <- ggplot(heroes, aes(x=heroes))+
geom_histogram()
q
table(heroes$heroes)
q <- ggplot(heroes, aes(x=heroes))+
geom_histogram(binwidth=1)
q
source('~/games/gitlab/mmho/hero_count.R')
View(heroes)
table(heroes$rating_for_week)
table(heroes$heroes)
q <- ggplot(heroes, aes(x=heroes, color=rating_for_week))+
geom_histogram(binwidth=1)
q
q <- ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_histogram(binwidth=1)
q
q <- ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_histogram(binwidth=1)+
geom_bar(position="dodge")
q
table(heroes$heroes, heroes$rating_for_week)
table(heroes$rating_for_week, heroes$heroes)
ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_histogram(binwidth=1)+
geom_bar(position="dodge")
ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_bar(position="dodge")+
geom_histogram(binwidth=1)
ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_bar(position="dodge", binwidth=1)
ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_freqpoly(binwidth=1000)
ggplot(heroes, aes(x=heroes, ..density.., fill=rating_for_week))+
geom_freqpoly(binwidth=1000)
ggplot(heroes, aes(x=heroes, fill=rating_for_week))+
geom_density()
ggplot(heroes, aes(x=heroes, color=rating_for_week))+
geom_density()
?read.csv
update.packages(checkBuilt=TRUE, ask=FALSE)
install.packages("dpylr")
install.packages("dplyr")
install.packages("dplyr", dependencies=TRUE)
rm(list = ls()); gc(); gc()
update.packages(checkBuilt=TRUE, ask=FALSE)
install.packages("ggplot2", dependencies=TRUE)
View(heroes)
View(heroes)
install.packages("httr")
rm(list = ls()); gc(); gc()
seq_along(5)
seq_along(1,5)
?seq_along
seq_len(5)
paste0("SELECT games_id, date_dim, sum(real_currency_eur) turnover, sum(net_net_eur) gimpli_net_eur, ",
"sum(coalesce(cast(substring_index(substring_index(`data`, '<turnover_minus_vat_minus_fees>', -1), '</turnover_minus_vat_minus_fees>', 1) as FLOAT),0)/exchange_rate) psm_net_eur ",
"from ao_emea_int_20.fct_payments_information ",
"WHERE date_dim between ", range[1], " and ", range[2], " ",
"and lower(status) = 'purchased' and games_id != 'AO ABE ALL' ",
"group by games_id, date_dim ",
"order by games_id, date_dim "
)
range <- c(20141101, 20150409)
range <- c(20141101, 20150415)
paste0("SELECT games_id, date_dim, sum(real_currency_eur) turnover, sum(net_net_eur) gimpli_net_eur, ",
"sum(coalesce(cast(substring_index(substring_index(`data`, '<turnover_minus_vat_minus_fees>', -1), '</turnover_minus_vat_minus_fees>', 1) as FLOAT),0)/exchange_rate) psm_net_eur ",
"from ao_emea_int_20.fct_payments_information ",
"WHERE date_dim between ", range[1], " and ", range[2], " ",
"and lower(status) = 'purchased' and games_id != 'AO ABE ALL' ",
"group by games_id, date_dim ",
"order by games_id, date_dim "
)
update.packages(checkBuilt = TRUE, ask = FALSE)
install.packages(c(knitr, yaml, htmltools, caTools, bitops, rmarkdown))
install.packages(c("knitr", "yaml", "htmltools", "caTools", "bitops", "rmarkdown"))
load("D:/gitlab/tso/biabb 2023 check TSO tracking.Rdata")
rm(heroes)
View(info)
View(add_remove)
info %>% filter(grepl('event', name, ignore.case=TRUE))
library(dplyr)
install.packages("dplyr")
info %>% filter(grepl('event', name, ignore.case=TRUE))
library(dplyr)
info %>% filter(grepl('event', name, ignore.case=TRUE))
?file.exists
?if
()
??if
??conditional
?load
?addDataFrame
update.packages(checkBuilt = TRUE, ask = FALSE)
update.packages(checkBuilt = TRUE, ask = FALSE)
library(shiny)
ui <- fluidPage()
server <- function(input, output){}
shinyApp(ui = ui, server = server)
library(shiny)
ui <- fluidPage("Hello World!")
server <- function(input, output){}
shinyApp(ui = ui, server = server)
library(shiny)
ui <- fluidPage(
sliderInput(inputId = "num",
label = "Choose a number",
value = 25, min = 1, max = 100),
plotOutput("hist")
)
server <- function(input, output){}
shinyApp(ui = ui, server = server)
library(shiny)
ui <- fluidPage(
sliderInput(inputId = "num",
label = "Choose a number",
value = 25, min = 1, max = 100),
plotOutput("hist")
)
server <- function(input, output){
output$hist <- renderPlot(
{
title <- paste0(input$num, " random normal values")
hist(rnorm(input$num), main = title)
}
)
}
shinyApp(ui = ui, server = server)
library(httr)
set_config(use_proxy(url="10.26.0.16", port=3128))
library(jsonlite)
d3 <- fromJSON("http://eu.battle.net/api/d3/profile/safferli-2527/")
set_config(use_proxy(url="10.26.0.16", port=3128))
d3 <- fromJSON("http://eu.battle.net/api/d3/profile/safferli-2527/")
update.packages(checkBuilt = TRUE, ask = FALSE)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jre7')
library("curl")
curl::ie_proxy_info()
sessionInfo()
update.packages(checkBuilt = TRUE)
library(rJava)
Sys.setenv(JAVA_HOME='C:\\Program Files\\Java\\jre1.8.0_51')
update.packages(checkBuilt = TRUE)
install.packages("fasttime",,"http://rforge.net/")
library(fasttime)
rm(list = ls()); gc(); gc()
options(bitmapType='cairo', scipen = 999)
library(data.table)
# library(lubridate)
library(magrittr)
library(dplyr)
library(ggplot2)
?rep_len
rm(list = ls()); gc(); gc()
options(bitmapType='cairo', scipen = 999)
library(data.table)
# library(lubridate)
library(magrittr)
library(dplyr)
library(ggplot2)
# set default tz to UTC to avoid any complications
start.period <- as.POSIXct("2016-01-01", "UTC") # POSIXct = seconds since epoch
period.increment <- 3600 # 1 hour = 3600 seconds
max.periods <- 50 # periods to simulate
influx.per.period <- 2000 # new players that arrive each period
players.per.server <- 1000 # number of players per server
f.gen.server <- function(x=server.number){
data.table(server.number = x,
player.number = seq_len(players.per.server),
end.time = as.POSIXct(NA))
}
f.flush.users <- function(data, x=current.period){
data[end.time < x, end.time := NA] ## flush users if their end.time is before the flush.time
}
f.add.servers <- function(data, x=influx.per.period) {
free.space <- sum(is.na(data$end.time)) ## check serverlist
if (free.space < influx.per.period) { # not enough room, need to requisition servers
current.servers <- nrow(data) / players.per.server
servers.needed <- ceiling((influx.per.period - free.space) / players.per.server)
# add old data and new needed servers to a list, bind everything into a single data.table at the end
# current.servers+seq_len(servers.needed) adds 1:n to current servers, e.g. 5 + 1:2 = c(6, 7)
data %<>% list %>% c(lapply(current.servers+seq_len(servers.needed), f.gen.server)) %>% rbindlist # add new servers to the servers df
} else { data }
}
f.gen.users <- function(x){
rlnorm(x, log(90), 0.7) * 60 # 1 minute = 60 seconds
}
f.fill.servers <- function(data=servers, x=influx.per.period, y=current.period) {
data_a <- data[!is.na(end.time)]
data_b <- data[is.na(end.time)] # here you can potentially arrange in a way to have fullest servers be first
data_b[1:x, end.time := .POSIXct(rep_len(y, x)) + f.gen.users(x)]
return(rbindlist(list(data_a, data_b)) %>% arrange(server.number, player.number))
}
f.remove.servers <- function(data) {
# potential free server available if free.space >= players.per.server
if (sum(is.na(data$end.time)) >= players.per.server) {
# remove unneeded servers
data %>% group_by(server.number) %>% filter(!all(is.na(end.time))) %>% ungroup
} else { data }
}
## main loop
f.simulate <- function(max.periods) {
servers <- f.gen.server(1)
current.period <- start.period
sim.data <- list()
for (i in 1:max.periods) {
servers %<>% f.flush.users(current.period) # flush old users
servers %<>% f.add.servers(influx.per.period)  # requisition servers if not enough room
servers %<>% f.fill.servers(influx.per.period, current.period) # we have enough room, now fill with players
servers %<>% f.remove.servers # remove unneeded servers
sim.data[[i]] <- data.table(
period = current.period,
players = sum(!is.na(servers$end.time)),
servers = (nrow(servers)/players.per.server),
players.per.last.server = sum(!is.na(tail(servers, n=players.per.server)$end.time)))
## increase timestamp
current.period <- current.period + period.increment
}
return(sim.data %>% rbindlist %>% mutate(last.server.efficiency = players.per.last.server / players.per.server))
}
sim.data <- f.simulate(100)
g <- sim.data  %>% ggplot()+
geom_line(aes(x=period, y=(servers*players.per.server)), size=1, colour="red")+
#geom_line(aes(x=period, y=(last.server.efficiency*players.per.server*max(sim.data$servers))), size=1, colour="green")+
geom_line(aes(x=period, y=players), size=1, colour="blue") +
labs(x = "", y = "Concurrent players", title = "Concurrent players (simulated) vs server capacity")
print(g)
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
?match.arg
f.influx.per.period <- function(x = "BRK") {
server <- match.arg(x, available.servers)
if (server == "BRK") {
# influx of new users into BRK
return(2000)
} else {
# pull players migrating from BRK to MAN
}
}
f.influx.per.period()
f.influx.per.period("BRK")
f.influx.per.period("MAN")
available.servers <- c("BRK", "MAN") # server types: BRK: Brooklyn, MAN: Manhattan
f.influx.per.period("MAN")
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
source('D:/gitlab/server-simulation/servers_v2.R', echo=TRUE)
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
?conditionalPanel
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
?actionButton
?eventReactive
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
?Progress
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
?assign
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
shiny::runApp('D:/gitlab/server-simulation/shiny/server_simulation')
library(installr)
updateR()
updateR()
library(slidify)
wd <- "D:/github/introduction_shiny"
setwd(wd)
author("shiny-introduction")
http://shiny.rstudio.com/articles/cheatsheet.html
